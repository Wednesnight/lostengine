/**
 * $Id: variant.cpp 173 2008-08-22 14:07:44Z unwesen $
 *
 * Copyright (C) 2007,2008 the authors.
 *
 * Author: Henning Pfeiffer <slashgod@users.sourceforge.net>
 * Author: Jens Finkhaeuser <unwesen@users.sourceforge.net>
 *
 * This file is part of the Fhtagn! C++ Library, and may be distributed under
 * the following license terms:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

#include <fhtagn/variant.h>

namespace fhtagn {

boost::shared_ptr<variant> variant::invalid_value;


void
variant::instanciate_invalid_value()
{
    if (!invalid_value) {
        invalid_value = boost::shared_ptr<variant>(new variant(IS_INVALID));
    }
}


variant::variant(variant_state state)
    : m_state(state)
    , m_data(0)
{
    // only used for null value, so don't instanciate again.
}


variant::variant()
    : m_state(IS_EMPTY)
    , m_data(0)
{
    instanciate_invalid_value();
}


variant::variant(variant const & other)
    : m_state(other.m_state)
    , m_data(other.m_data ? other.m_data->clone() : 0)
{
    instanciate_invalid_value();
}


variant::~variant()
{
    delete m_data;
}


variant &
variant::operator=(variant const & other)
{
    // never ever change the state of the invalid value.
    if (m_state == IS_INVALID) {
      throw error("Cannot assign to the variant::invalid_value!");
    }

    if (this != &other) {
        m_state = other.m_state;
        delete m_data;
        m_data = other.m_data ? other.m_data->clone() : 0;
    }
    return *this;
}


variant &
variant::operator[](uint32_t index)
{
    switch (m_state) {
        case IS_INVALID:
        case IS_EMPTY:
            // Delay the reaction to this error by handing out the invalid value.
            // Since we also go to this branch if the [] operator is called on
            // the invalid value, only the final result of a chain of [] will
            // throw an error.
            return *invalid_value.get();
            break;

        case IS_VALUE:
            if (!is<array_t>() || index >= as<array_t>().size()) {
              // we can add a simple check for the validity of the index -
              // not because we want to fundamentally change how array_t
              // like containers are provided by the STL, but because we
              // can again delay reaction to erroneous input.
              return *invalid_value.get();
            }
            return as<array_t>()[index];
            break;

        default:
            assert(0);
    }
    return *invalid_value.get();
}


variant const &
variant::operator[](uint32_t index) const
{
    switch (m_state) {
        case IS_INVALID:
        case IS_EMPTY:
            // Delay the reaction to this error ...
            return *invalid_value.get();
            break;

        case IS_VALUE:
            if (!is<array_t>() || index >= as<array_t>().size()) {
              return *invalid_value.get();
            }
            return as<array_t>()[index];
            break;

        default:
            assert(0);
    }
    return *invalid_value.get();
}



variant &
variant::operator[](std::string const & key)
{
    switch (m_state) {
        case IS_INVALID:
            // Delay reaction to this error...
            return *invalid_value.get();
            break;

        case IS_EMPTY:
            // In this particular case, let's deviate from the theme of
            // returning the invalid value - the reason is that on
            // non-const maps the expected behaviour is to silently add
            // new kv-pairs. On const maps, that can't work...
            m_data = new data<map_t>();
            m_state = IS_VALUE;
            // fall through

        case IS_VALUE:
            if (is<map_t>()) {
                return as<map_t>()[key];
            }
            return *invalid_value.get();
            break;

        default:
            assert(0);
    }
    return *invalid_value.get();
}



variant const &
variant::operator[](std::string const & key) const
{
    switch (m_state) {
        case IS_INVALID:
        case IS_EMPTY:
            // Delay reaction...
            return *invalid_value.get();
            break;

        case IS_VALUE:
            if (is<map_t>()) {
                map_t::const_iterator iter = as<map_t>().find(key);
                if (iter == as<map_t>().end()) {
                  return *invalid_value.get();
                }
                return iter->second;
            }
            return *invalid_value.get();

        default:
            assert(0);
    }
    return *invalid_value.get();
}


bool
variant::operator==(variant const & other) const
{
    if (!m_data || !other.m_data) {
        throw FHTAGN_VARIANT_COMPARISON_ERROR;
    }
    return (*m_data == *other.m_data);
}


bool
variant::operator<(variant const & other) const
{
    if (!m_data || !other.m_data) {
        throw FHTAGN_VARIANT_COMPARISON_ERROR;
    }
    return (*m_data < *other.m_data);
}


bool
variant::operator<=(variant const & other) const
{
    if (!m_data || !other.m_data) {
        throw FHTAGN_VARIANT_COMPARISON_ERROR;
    }
    return (*m_data <= *other.m_data);
}


bool
variant::operator>(variant const & other) const
{
    if (!m_data || !other.m_data) {
        throw FHTAGN_VARIANT_COMPARISON_ERROR;
    }
    return (*m_data > *other.m_data);
}


bool
variant::operator>=(variant const & other) const
{
    if (!m_data || !other.m_data) {
        throw FHTAGN_VARIANT_COMPARISON_ERROR;
    }
    return (*m_data >= *other.m_data);
}


bool
variant::operator!=(variant const & other) const
{
    if (!m_data || !other.m_data) {
        throw FHTAGN_VARIANT_COMPARISON_ERROR;
    }
    return (*m_data != *other.m_data);
}



} // namespace fhtagn
