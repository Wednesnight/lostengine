/**
 * $Id: lock_policy.h 197 2008-11-02 12:02:37Z unwesen $
 *
 * Copyright (C) 2008 the authors.
 *
 * Author: Jens Finkhaeuser <unwesen@users.sourceforge.net>
 *
 * This file is part of the Fhtagn! C++ Library, and may be distributed under
 * the following license terms:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
#ifndef FHTAGN_THREADS_LOCK_POLICY_H
#define FHTAGN_THREADS_LOCK_POLICY_H

#ifndef __cplusplus
#error You are trying to include a C++ only header file
#endif

#include <fhtagn/fhtagn.h>

/**
 * Lock policies are classes injected into an algorithm, container or other
 * piece of code at compile time that the code delegates to in order to perform
 * mutual exclusion. The most prominent reason for factoring out the policy is
 * to avoid incurring the overhead of locking or unlocking mutexes when the code
 * in question is intended to be used in a single-threaded environment.
 *
 * An example of such code making use of lock policies might look like this:
 *
 *    template <typename lock_policyT>
 *    void foo(...)
 *    {
 *        // code before critical section
 *
 *        // enter critical section
 *        lock_policyT::lock();
 *
 *        // code in critical section
 *
 *        // leave critical section
 *        lock_policyT::unlock();
 *
 *        // code after critical section
 *    }
 *
 * It's up to the lock_policyT to determine whether or not the lock()/unlock()
 * functions perform any mutex locking, or are no-ops.
 *
 * Fortunately, boost::thread already provides a nicely unified interface for
 * the mutexes and locks it contains. The basic pattern is this:
 *
 *    * Each mutex class contains at least an embedded type scoped_lock
 *    * Those mutex classes that support lock types that may fail at locking
 *      support additional embedded types, which are scoped_try_lock and
 *      scoped_timed_lock at the time of writing.
 *
 * In essence, the above code snippet can easily rewritten to accomodate either
 * recursive or non-recursive boost mutexes in the following manner:
 *
 *    template <typename mutexT>
 *    void foo(...)
 *    {
 *        // code before critical section
 *
 *        // enter critical section
 *        {
 *            static mutexT m;
 *            typename mutexT::scoped_lock l(m);
 *
 *            // code in critical section
 *
 *            // leave critical section
 *        }
 *
 *        // code after critical section
 *    }
 *
 * In other words, boost's mutex interface is almost good enough to implement
 * code with lock policies, except for two things:
 *
 *    1. Boost does *not* provide a mutex type that does nothing, i.e. all of
 *       it's lock types incur some overhead. We remedy that by providing a
 *       mutex types with the same interface as boost's mutexes.
 *
 *       Actually, we provide more than one mutex type. The first one,
 *       fake_mutex, really does nothing at all. It implements the interfaces of
 *       Lockable, TimedLockable, SharedLockable and UpgradeLockable, but all of
 *       it's functions will *always* succeed.
 *
 *       That is probably what is best when designing an algorithm to work both
 *       in a threaded and non-threaded environment.
 **/
#include <fhtagn/threads/detail/fake_mutex.h>
/**
 *       On the other hand, code that relies on specific *behaviour* of a mutex
 *       class, such as try_lock() succeeding or failing depending on whether
 *       the mutex is already locked, would break.
 *
 *       To deal with those situations, we provide pseudo_mutex. It implements
 *       the Lockable, TimedLockable and SharedLockable interfaces, and
 *       actually flags whether or not it's locked. But it's not thread-safe,
 *       and will pretty much only work in a single thread.
 *
 **/
#include <fhtagn/threads/detail/pseudo_mutex.h>
 /**
  *      Another way of thinking of these mutexes is that in a single thread,
  *      fake_mutex exhibits the same behaviour as a recursive_mutex, whereas
  *      pseudo_mutex exhibits that of a mutex.
  *
  *      XXX None of the mutexes simulate the UpgradeLockable behaviour.
  **/

/**
 *    2. We'd like to know as early as possible and as quickly as possible
 *       whether or not our selected mutex type works with the expectations of
 *       the algorithm making use of it. In particular, we'd like to know
 *       whether the mutex type provides the scoped_try_lock or
 *       scoped_timed_lock types. To help out in that area, we provide a few
 *       pre-defined boost::concept definitions that one can check for in code
 *       making use of lock policies.
 **/
#include <fhtagn/threads/detail/mutex_concepts.h>


#endif // guard
