/**
 * $Id: property.h 197 2008-11-02 12:02:37Z unwesen $
 *
 * Copyright (C) 2007 the authors.
 *
 * Author: Jens Finkhaeuser <unwesen@users.sourceforge.net>
 *
 * This file is part of the Fhtagn! C++ Library, and may be distributed under
 * the following license terms:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
#ifndef FHTAGN_PROPERTY_H
#define FHTAGN_PROPERTY_H

#ifndef __cplusplus
#error You are trying to include a C++ only header file
#endif

#include <fhtagn/fhtagn.h>

#include <functional>

#include <boost/concept_check.hpp>

namespace fhtagn {

namespace concepts {

/**
 * The ReadPropertyTagConcept and WritePropertyTagConcept below are used to
 * provide compile-time checks on the property class further down in this file.
 **/
template <typename T>
struct ReadPropertyTagConcept
{
    void constraints()
    {
        T::read();
    }
};

template <typename T>
struct WritePropertyTagConcept
{
    void constraints()
    {
        T::write();
    }
};

} // namespace concepts

/** Conforms to the ReadPropertyTagConcept and the WritePropertyTagConcept */
struct read_write_property
{
    static inline void read() {}
    static inline void write() {}
};

/** Conforms to the ReadPropertyTagConcept */
struct read_only_property
{
    static inline void read() {}
};

/** Conforms to the WritePropertyTagConcept */
struct write_only_property
{
    static inline void write() {}
};




/**
 * Many programming languages support class properties - that is, class members
 * that behave like regular data members, but internally delegate to a getter
 * and setter method to retrieve/modify values.
 *
 * From a readability point of view, this certainly beats using getters and
 * setters manually, even though internally the code isn't vastly different.
 *
 * Using interceptable from <fhtagn/interceptable.h>, this class provides such a
 * convenience wrapper for creating class properties.
 *
 * The property template class is parametrized using two parameters: the first
 * is the regular data type to simulate, and the second the type of the class
 * holding the property:
 *
 *    struct X
 *    {
 *        property<int, X>    my_property;
 *
 *        X::X();
 *        int get() const;
 *        void set(int const &);
 *    };
 *
 * There is a third template parameter to the property class specifying whether
 * the property is a read-only, write-only or read-write property (the default
 * makes it a read-write property). If you attempt to assign a value to a
 * read-only property, or in fact if you attempt to pass a setter to the
 * constructor of a read-only property, the compilation will fail.
 *
 * The types you should use to define what access you want to allow on your
 * property are fhtagn::read_only_property, fhtagn::write_only_property and
 * fhtagn::read_write_property.
 *
 * The property class provides three constructors. One accepts a member function
 * pointer to a setter function, one accepts a member function pointer to a
 * getter function, and one accepts both. Using these constructors works only in
 * combination with the correct property access tag, i.e. a read_only_property
 * will only compile when you use the constructor that accepts a getter, but no
 * setter, etc.
 *
 * All constructors also require a pointer to parent_classT, in order to be able
 * to delegate to the correct parent object for access:
 *
 *    X::X()
 *        : my_property(this, &X::get, &X::set)
 *    {
 *    }
 *
 * Properties should be used just as a public data member of a class would be -
 * the only difference is that reading and writing the property is handled by
 * wrapped functions. To this end, the property class defines many operators.
 *
 *    X x;
 *    int y = x.my_property + 42; // works just as expected.
 *
 * The operators provided can be roughly divided into two classes:
 *  - Operators that modify the property value, such as assignment operators
 *  - Operators that return the property value, without modifications
 *
 * Explicitly not provided are operators that read the property value, modify
 * it, and return a temporary with the result, such as (for example) a simple
 * addition operator, because it makes no sense to do so for a property.
 **/
template <
    /** The type to "simulate" in the property */
    typename reprT,
    /** Parent class holding the property */
    typename parent_classT,
    /** Define the available access methods on the property */
    typename property_access_tagT = read_write_property
>
class property
{
public:
    /** convenience */
    typedef property<reprT, parent_classT, property_access_tagT> own_type;

    /**
     * std::mem_fun types are used, because they relieve us of also
     * holding a reference to the actual instance of holderT
     * whose property we are describing.
     **/
    typedef std::const_mem_fun_t<reprT, parent_classT>            getter_type;
    typedef std::mem_fun1_t<void, parent_classT, reprT const &>   setter_type;

    /**
     * On the other hand, the *_param_type typedefs allow us to use
     * construct a property class using simple pointer-to-member-functions
     * instead of mem_fun-type objects.
     **/
    typedef reprT (parent_classT::*getter_param_type)() const;
    typedef void (parent_classT::*setter_param_type)(reprT const &);


    /** Constructor for read-only properties */
    property(parent_classT * parent, getter_param_type getter)
        : m_parent(parent)
        , m_getter(getter)
        , m_setter(0)
    {
        boost::function_requires<concepts::ReadPropertyTagConcept<property_access_tagT> >();
    }


    /** Constructor for write-only properties */
    property(parent_classT * parent, setter_param_type setter)
        : m_parent(parent)
        , m_getter(0)
        , m_setter(setter)
    {
        boost::function_requires<concepts::WritePropertyTagConcept<property_access_tagT> >();
    }


    /** Constructor for read-write properties */
    property(parent_classT * parent, getter_param_type getter,
            setter_param_type setter)
        : m_parent(parent)
        , m_getter(getter)
        , m_setter(setter)
    {
        boost::function_requires<concepts::ReadPropertyTagConcept<property_access_tagT> >();
        boost::function_requires<concepts::WritePropertyTagConcept<property_access_tagT> >();
    }


    /**
     * Because properties require their parent pointer, they are not implicitly
     * copyable - you need to copy them explicitly in a copy ctor.
     **/
    property(parent_classT * parent, own_type const & other)
        : m_parent(parent)
        , m_getter(other.m_getter)
        , m_setter(other.m_setter)
    {
        // since this is copy-constructed from another property of exactly the
        // same type, and this other property must have been constructed in some
        // way, it's safe to assume that own_type satisfies the requirements
        // of the ReadProperty and WriteProperty concepts
    }


    /** Assignment operators */
    template <typename otherT>
    own_type & operator=(otherT const & other)
    {
        boost::function_requires<concepts::WritePropertyTagConcept<property_access_tagT> >();
        m_setter(m_parent, other);
        return *this;
    }

    template <typename otherT>
    own_type & operator*=(otherT const & other)
    {
        boost::function_requires<concepts::ReadPropertyTagConcept<property_access_tagT> >();
        boost::function_requires<concepts::WritePropertyTagConcept<property_access_tagT> >();
        reprT tmp = m_getter(m_parent);
        tmp *= other;
        m_setter(m_parent, tmp);
        return *this;
    }

    template <typename otherT>
    own_type & operator/=(otherT const & other)
    {
        boost::function_requires<concepts::ReadPropertyTagConcept<property_access_tagT> >();
        boost::function_requires<concepts::WritePropertyTagConcept<property_access_tagT> >();
        reprT tmp = m_getter(m_parent);
        tmp /= other;
        m_setter(m_parent, tmp);
        return *this;
    }

    template <typename otherT>
    own_type & operator%=(otherT const & other)
    {
        boost::function_requires<concepts::ReadPropertyTagConcept<property_access_tagT> >();
        boost::function_requires<concepts::WritePropertyTagConcept<property_access_tagT> >();
        reprT tmp = m_getter(m_parent);
        tmp %= other;
        m_setter(m_parent, tmp);
        return *this;
    }

    template <typename otherT>
    own_type & operator+=(otherT const & other)
    {
        boost::function_requires<concepts::ReadPropertyTagConcept<property_access_tagT> >();
        boost::function_requires<concepts::WritePropertyTagConcept<property_access_tagT> >();
        reprT tmp = m_getter(m_parent);
        tmp += other;
        m_setter(m_parent, tmp);
        return *this;
    }

    template <typename otherT>
    own_type & operator-=(otherT const & other)
    {
        boost::function_requires<concepts::ReadPropertyTagConcept<property_access_tagT> >();
        boost::function_requires<concepts::WritePropertyTagConcept<property_access_tagT> >();
        reprT tmp = m_getter(m_parent);
        tmp -= other;
        m_setter(m_parent, tmp);
        return *this;
    }

    template <typename otherT>
    own_type & operator<<=(otherT const & other)
    {
        boost::function_requires<concepts::ReadPropertyTagConcept<property_access_tagT> >();
        boost::function_requires<concepts::WritePropertyTagConcept<property_access_tagT> >();
        reprT tmp = m_getter(m_parent);
        tmp <<= other;
        m_setter(m_parent, tmp);
        return *this;
    }

    template <typename otherT>
    own_type & operator>>=(otherT const & other)
    {
        boost::function_requires<concepts::ReadPropertyTagConcept<property_access_tagT> >();
        boost::function_requires<concepts::WritePropertyTagConcept<property_access_tagT> >();
        reprT tmp = m_getter(m_parent);
        tmp >>= other;
        m_setter(m_parent, tmp);
        return *this;
    }

    template <typename otherT>
    own_type & operator&=(otherT const & other)
    {
        boost::function_requires<concepts::ReadPropertyTagConcept<property_access_tagT> >();
        boost::function_requires<concepts::WritePropertyTagConcept<property_access_tagT> >();
        reprT tmp = m_getter(m_parent);
        tmp &= other;
        m_setter(m_parent, tmp);
        return *this;
    }

    template <typename otherT>
    own_type & operator^=(otherT const & other)
    {
        boost::function_requires<concepts::ReadPropertyTagConcept<property_access_tagT> >();
        boost::function_requires<concepts::WritePropertyTagConcept<property_access_tagT> >();
        reprT tmp = m_getter(m_parent);
        tmp ^= other;
        m_setter(m_parent, tmp);
        return *this;
    }

    template <typename otherT>
    own_type & operator|=(otherT const & other)
    {
        boost::function_requires<concepts::ReadPropertyTagConcept<property_access_tagT> >();
        boost::function_requires<concepts::WritePropertyTagConcept<property_access_tagT> >();
        reprT tmp = m_getter(m_parent);
        tmp |= other;
        m_setter(m_parent, tmp);
        return *this;
    }

    /** Arithmetic operators */

    // prefix operator ++
    own_type & operator++()
    {
        boost::function_requires<concepts::ReadPropertyTagConcept<property_access_tagT> >();
        boost::function_requires<concepts::WritePropertyTagConcept<property_access_tagT> >();
        reprT tmp = m_getter(m_parent);
        ++tmp;
        m_setter(m_parent, tmp);
        return *this;
    }

    // prefix operator --
    own_type & operator--()
    {
        boost::function_requires<concepts::ReadPropertyTagConcept<property_access_tagT> >();
        boost::function_requires<concepts::WritePropertyTagConcept<property_access_tagT> >();
        reprT tmp = m_getter(m_parent);
        --tmp;
        m_setter(m_parent, tmp);
        return *this;
    }

    /** Subscript operator */
    template <typename retT, typename otherT>
    retT & operator[](otherT const & other)
    {
        boost::function_requires<concepts::ReadPropertyTagConcept<property_access_tagT> >();
        reprT & tmp = m_getter(m_parent);
        return tmp[other];
    }

    template <typename retT, typename otherT>
    retT const & operator[](otherT const & other) const
    {
        boost::function_requires<concepts::ReadPropertyTagConcept<property_access_tagT> >();
        reprT const & tmp = m_getter(m_parent);
        return tmp[other];
    }

    /** Casting operator for the wrapped type. */
    operator reprT() const
    {
        boost::function_requires<concepts::ReadPropertyTagConcept<property_access_tagT> >();
        return m_getter(m_parent);
    }

private:
    /** Cannot be default-constructed */
    property();

    /**
     * Cannot be assigned. It makes no sense to assign one property to another
     * directly, as the semantics for assigning m_parent, m_getter and m_setter
     * are odd at best. Assinging the /value/ of one property to another property
     * works just fine by (implicitly) using the cast operator to reprT and the
     * assignment operator for any otherT that isn't a property.
     **/
    property & operator=(property const & other);

    /** Holds pointer to parent class */
    parent_classT * m_parent;

    /** Holds getter function/functor */
    getter_type m_getter;

    /** Holds setter function/functor */
    setter_type m_setter;
};


} // namespace fhtagn

#endif // guard
