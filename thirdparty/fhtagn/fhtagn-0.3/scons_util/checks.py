#
# $Id: checks.py 16 2009-05-02 21:31:27Z unwesen $
#
# Copyright (C) 2007,2008,2009 the authors.
#
# Author: Jens Finkhaeuser <unwesen@users.sourceforge.net>
#
# This file is part of the SCons utilities library, and may be distributed under
# the following license terms:
#
# Boost Software License - Version 1.0 - August 17th, 2003
#
# Permission is hereby granted, free of charge, to any person or organization
# obtaining a copy of the software and accompanying documentation covered by
# this license (the "Software") to use, reproduce, display, distribute,
# execute, and transmit the Software, and to prepare derivative works of the
# Software, and to permit third-parties to whom the Software is furnished to
# do so, all subject to the following:
#
# The copyright notices in the Software and this entire statement, including
# the above license grant, this restriction and the following disclaimer,
# must be included in all copies of the Software, in whole or in part, and
# all derivative works of the Software, unless such copies or derivative
# works are solely in the form of machine-executable object code generated by
# a source language processor.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
# SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
# FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

class Callable:
  def __init__(self, anycallable):
    self.__call__ = anycallable

##############################################################################
# check for byteorder
class ByteorderCheck(object):
  def register_options(opts = None):
    pass
  register_options = Callable(register_options)

  def check_for_byteorder(context, *args, **kw):
    context.Message("Checking byteorder... ")
    import sys
    if sys.byteorder == "big":
      context.sconf.Define('WORDS_BIGENDIAN', '1', 'Bigendian byteorder')
      context.Result('big endian')
    else:
      context.Result('little endian')
    return 0
  check_for_byteorder = Callable(check_for_byteorder)

  def init(self, testdict):
    if not self.has_key(testdict):
      self[testdict] = {}
    self[testdict]['ByteorderCheck'] = ByteorderCheck.check_for_byteorder
  init = Callable(init)


##############################################################################
# check for boost libraries

class BoostCheck(object):

  def register_options(opts = None):
    from SCons.Script import PathOption
    if opts:
      opts.Add(PathOption('BOOST_PREFIX', 'Base path of boost installation; '
            'use this if auto-detection fails.', None))
  register_options = Callable(register_options)


  def check_for_boost(context, *args, **kw):
    kw['test_file'] = """
#include <iostream>
#include <boost/version.hpp>

int main(int argc, char **argv)
{
  std::cout << (BOOST_VERSION / 100000) << "."
            << (BOOST_VERSION / 100 % 1000) << "."
            << BOOST_VERSION % 100
            << std::endl;
}
"""
    env = context.sconf.env

    compiler_tag = ''
    if env.has_key('MSVS'):
      if env['MSVS'].has_key('VERSION'):
        version = env['MSVS']['VERSION']
        compiler_tag = '-vc%s%s' % tuple(version.split('.'))

    lib_prefix = ''
    if kw.get('prefer_static', False):
      if not env.is_unix():
        # Static libs on win32 are prefix with 'lib'
        lib_prefix = 'lib'

    lib_patterns = {}
    for libname in kw.get('LIBS', []):
      pattern = '(?P<LINK_NAME>%sboost_%s((%s)?-mt)?(-(?P<VERSION_MAJOR>[0-9]+)_(?P<VERSION_MINOR>[0-9]+))?)' % (
          lib_prefix, libname, compiler_tag)
      lib_patterns[libname] = [
        r'%s%s%s' % (env['LIBPREFIX'], pattern, env['LIBSUFFIX']),
        r'%s%s%s' % (env['SHLIBPREFIX'], pattern, env['SHLIBSUFFIX']),
      ]
    kw['lib_patterns'] = lib_patterns
    kw['header_only'] = True
    kw['suffix'] = '.cpp'

    return env.check_for_lib(context, 'boost', **kw)
  check_for_boost = Callable(check_for_boost)


  def init(self, testdict):
    if not self.has_key(testdict):
      self[testdict] = {}
    self[testdict]['BoostCheck'] = BoostCheck.check_for_boost
  init = Callable(init)



##############################################################################
# check for cppunit libraries

class CppUnitCheck(object):

  def register_options(opts = None):
    from SCons.Script import PathOption
    if opts:
      opts.Add(PathOption('CPPUNIT_PREFIX', 'Base path of cppunit installation;'
              ' use this if auto-detection fails.', None))
  register_options = Callable(register_options)


  def check_for_cppunit(context, *args, **kw):
    kw['test_file'] = """
#include <iostream>
#include <cppunit/Portability.h>

int main(int argc, char **argv)
{
  std::cout << CPPUNIT_VERSION << std::endl;
}
"""
    kw['suffix'] = '.cpp'
    kw['header_only'] = True
    return context.sconf.env.check_for_lib(context, 'cppunit', **kw)
  check_for_cppunit = Callable(check_for_cppunit)


  def init(self, testdict):
    if not self.has_key(testdict):
      self[testdict] = {}
    self[testdict]['CppUnitCheck'] = CppUnitCheck.check_for_cppunit
  init = Callable(init)



##############################################################################
# check for fhtagn libraries

class FhtagnCheck(object):

  def register_options(opts = None):
    from SCons.Script import PathOption
    if opts:
      opts.Add(PathOption('FHTAGN_PREFIX', 'Base path of fhtagn installation; '
              'use this if auto-detection fails.', None))
  register_options = Callable(register_options)


  def check_for_fhtagn(context, *args, **kw):
    kw['test_file'] = """
#include <iostream>
#include <fhtagn/version.h>

int main(int argc, char **argv)
{
  std::pair<uint16_t, uint16_t> version = fhtagn::version();
  std::cout << version.first << "." << version.second << std::endl;
}
"""
    kw['suffix'] = '.cpp'
    kw['lib_names'] = ['fhtagn']
    return context.sconf.env.check_for_lib(context, 'fhtagn', **kw)
  check_for_fhtagn = Callable(check_for_fhtagn)


  def init(self, testdict):
    if not self.has_key(testdict):
      self[testdict] = {}
    self[testdict]['FhtagnCheck'] = FhtagnCheck.check_for_fhtagn
  init = Callable(init)


##############################################################################
# check for cartograph

class CartographCheck(object):

  def register_options(opts = None):
    from SCons.Script import PathOption
    if opts:
      opts.Add(PathOption('CARTOGRAPH_PREFIX', 'Base path of cartograph '
            'installation; assumed to be a Framework.', None))
  register_options = Callable(register_options)


  def check_for_cartograph(context, *args, **kw):
    kw['test_file'] = """
#include <iostream>
#include <cartograph/version.h>

int main(int argc, char **argv)
{
  std::pair<uint16_t, uint16_t> version = cartograph::version();
  std::cout << version.first << "." << version.second << std::endl;
}
"""
    kw['suffix'] = '.cpp'
    return context.sconf.env.check_for_lib(context, 'cartograph', **kw)
  check_for_cartograph = Callable(check_for_cartograph)


  def init(self, testdict):
    if not self.has_key(testdict):
      self[testdict] = {}
    self[testdict]['CartographCheck'] = CartographCheck.check_for_cartograph
  init = Callable(init)




##############################################################################
# check for OpenSceneGraph frameworks

class OSGCheck(object):

  def register_options(opts = None):
    from SCons.Script import PathOption
    if opts:
      opts.Add(PathOption('OSG_PREFIX', 'Base path of OpenSceneGraph '
            'installation; assumed to be a Framework.', None))
  register_options = Callable(register_options)


  def check_for_osg(context, *args, **kw):
    kw['test_file'] = """
#include <iostream>
#include <osg/Version>

int main(int argc, char **argv)
{
  std::cout << osgGetVersion() << std::endl;
}
"""
    kw['suffix'] = '.cpp'
    return context.sconf.env.check_for_framework(context, 'osg', **kw)
  check_for_osg = Callable(check_for_osg)


  def init(self, testdict):
    if not self.has_key(testdict):
      self[testdict] = {}
    self[testdict]['OSGCheck'] = OSGCheck.check_for_osg
  init = Callable(init)


